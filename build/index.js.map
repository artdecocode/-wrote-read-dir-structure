{"version":3,"sources":["../src/index.js"],"names":["lstatFiles","dirPath","dirContent","readFiles","map","relativePath","path","ls","lstat","res","Promise","all","isDirectory","lstatRes","isNotDirectory","getType","isFile","isSymbolicLink","readDirStructure","Error","err","code","dir","readdir","lsr","directories","filter","notDirectories","files","reduce","acc","current","type","dirs","structure","content"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;;;AAEA;;;;;;AAMA,eAAeA,UAAf,CAA0BC,OAA1B,EAAmCC,UAAnC,EAA+C;AAC7C,QAAMC,YAAYD,WAAWE,GAAX,CAAe,MAAOC,YAAP,IAAwB;AACvD,UAAMC,OAAO,mBAAQL,OAAR,EAAiBI,YAAjB,CAAb;AACA,UAAME,KAAK,MAAM,0BAAYC,SAAZ,EAAmBF,IAAnB,CAAjB;AACA,WAAO;AACLE,aAAOD,EADF;AAELD,UAFK;AAGLD;AAHK,KAAP;AAKD,GARiB,CAAlB;AASA,QAAMI,MAAM,MAAMC,QAAQC,GAAR,CAAYR,SAAZ,CAAlB;AACA,SAAOM,GAAP;AACD;AAED;;;;;;;AAKA,MAAMG,cAAcC,YAAYA,SAASL,KAAT,CAAeI,WAAf,EAAhC;AACA;;;;;;;AAKA,MAAME,iBAAiBD,YAAY,CAACA,SAASL,KAAT,CAAeI,WAAf,EAApC;;AAEA,MAAMG,UAAWF,QAAD,IAAc;AAC5B,MAAIA,SAASL,KAAT,CAAeI,WAAf,EAAJ,EAAkC;AAChC,WAAO,WAAP;AACD;;AACD,MAAIC,SAASL,KAAT,CAAeQ,MAAf,EAAJ,EAA6B;AAC3B,WAAO,MAAP;AACD;;AACD,MAAIH,SAASL,KAAT,CAAeS,cAAf,EAAJ,EAAqC;AACnC,WAAO,cAAP;AACD;AACF,CAVD;AAYA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0Be,eAAeC,gBAAf,CAAgCjB,OAAhC,EAAyC;AACtD,MAAI,CAACA,OAAL,EAAc;AACZ,UAAM,IAAIkB,KAAJ,CAAU,wCAAV,CAAN;AACD;;AACD,QAAMZ,KAAK,MAAM,0BAAYC,SAAZ,EAAmBP,OAAnB,CAAjB;;AACA,MAAI,CAACM,GAAGK,WAAH,EAAL,EAAuB;AACrB,UAAMQ,MAAM,IAAID,KAAJ,CAAU,yBAAV,CAAZ;AACAC,QAAIC,IAAJ,GAAW,SAAX;AACA,UAAMD,GAAN;AACD;;AACD,QAAME,MAAM,MAAM,0BAAYC,WAAZ,EAAqBtB,OAArB,CAAlB;AACA,QAAMuB,MAAM,MAAMxB,WAAWC,OAAX,EAAoBqB,GAApB,CAAlB;AAEA,QAAMG,cAAcD,IAAIE,MAAJ,CAAWd,WAAX,CAApB,CAbsD,CAaV;;AAC5C,QAAMe,iBAAiBH,IAAIE,MAAJ,CAAWZ,cAAX,CAAvB;AAEA,QAAMc,QAAQD,eAAeE,MAAf,CAAsB,CAACC,GAAD,EAAMC,OAAN,KAAkB;AACpD,UAAMC,OAAOjB,QAAQgB,OAAR,CAAb;AACA,WAAO,EACL,GAAGD,GADE;AAEL,OAACC,QAAQ1B,YAAT,GAAwB;AACtB2B;AADsB;AAFnB,KAAP;AAMD,GARa,EAQX,EARW,CAAd;AAUA,QAAMC,OAAO,MAAMR,YAAYI,MAAZ,CAAmB,OAAOC,GAAP,EAAY;AAAExB,QAAF;AAAQD;AAAR,GAAZ,KAAuC;AAC3E,UAAMI,MAAM,MAAMqB,GAAlB;AACA,UAAMI,YAAY,MAAMhB,iBAAiBZ,IAAjB,CAAxB;AACA,WAAO,EACL,GAAGG,GADE;AAEL,OAACJ,YAAD,GAAgB6B;AAFX,KAAP;AAID,GAPkB,EAOhB,EAPgB,CAAnB;AASA,QAAMC,UAAU,EACd,GAAGP,KADW;AAEd,OAAGK;AAFW,GAAhB;AAIA,SAAO;AACLE,WADK;AAELH,UAAM;AAFD,GAAP;AAID;AAGD","sourcesContent":["import { lstat, readdir } from 'fs'\nimport makePromise from 'makepromise'\nimport { resolve } from 'path'\n\n/**\n * Update information about directory's content with lstat.\n * @param {string} dirPath Path to the root directory\n * @param {string[]} dirContent\n * @returns {File[]} An array with file objects.\n */\nasync function lstatFiles(dirPath, dirContent) {\n  const readFiles = dirContent.map(async (relativePath) => {\n    const path = resolve(dirPath, relativePath)\n    const ls = await makePromise(lstat, path)\n    return {\n      lstat: ls,\n      path,\n      relativePath,\n    }\n  })\n  const res = await Promise.all(readFiles)\n  return res\n}\n\n/**\n * Check if lstat result is a directory\n * @param {LstatRes} lstatRes Result of lib.lstatFiles\n * @returns {boolean} true if is a directory\n */\nconst isDirectory = lstatRes => lstatRes.lstat.isDirectory()\n/**\n * Check if lstat result is not a directory\n * @param {LstatRes} lstatRes Result of lib.lstatFiles\n * @returns {boolean} true if is not a directory\n */\nconst isNotDirectory = lstatRes => !lstatRes.lstat.isDirectory()\n\nconst getType = (lstatRes) => {\n  if (lstatRes.lstat.isDirectory()) {\n    return 'Directory'\n  }\n  if (lstatRes.lstat.isFile()) {\n    return 'File'\n  }\n  if (lstatRes.lstat.isSymbolicLink()) {\n    return 'SymbolicLink'\n  }\n}\n\n/**\n * Read a directory, and return its structure as an object. Only `Files`, `Directories` and `Symlinks` are included!\n * @param {string} dirPath Path to the directory.\n * @returns {Promise.<DirectoryStructure>} An object reflecting the directory structure.\n * @example\n *\n * const res = await readDirStructure('dir')\n *\n * {\n *  type: 'Directory',\n *  content: {\n *    'data.txt': {\n *      type: 'File'\n *    },\n\n *    subdir: {\n *      type: 'Directory',\n *      content: {\n *        'data-ln.txt': {\n *          type: 'SymbolicLink'\n *        },\n *      }\n *    }\n *  }\n * }\n */\nexport default async function readDirStructure(dirPath) {\n  if (!dirPath) {\n    throw new Error('Please specify a path to the directory')\n  }\n  const ls = await makePromise(lstat, dirPath)\n  if (!ls.isDirectory()) {\n    const err = new Error('Path is not a directory')\n    err.code = 'ENOTDIR'\n    throw err\n  }\n  const dir = await makePromise(readdir, dirPath)\n  const lsr = await lstatFiles(dirPath, dir)\n\n  const directories = lsr.filter(isDirectory) // reduce at once\n  const notDirectories = lsr.filter(isNotDirectory)\n\n  const files = notDirectories.reduce((acc, current) => {\n    const type = getType(current)\n    return {\n      ...acc,\n      [current.relativePath]: {\n        type,\n      },\n    }\n  }, {})\n\n  const dirs = await directories.reduce(async (acc, { path, relativePath }) => {\n    const res = await acc\n    const structure = await readDirStructure(path)\n    return {\n      ...res,\n      [relativePath]: structure,\n    }\n  }, {})\n\n  const content = {\n    ...files,\n    ...dirs,\n  }\n  return {\n    content,\n    type: 'Directory',\n  }\n}\n\n\n/**\n * A directory structure representation\n * { dir: subdir: { 'fileA.txt': 'foo', 'fileB.js': 'bar' }, 'fileC.jpg': 'baz' }\n * @typedef {Object} LstatRes\n * @property {fs.Stats} lstat\n * @property {string} relativePath\n *\n * A directory structure representation\n * @typedef {Object} DirectoryStructure\n * @property {string} type File type, e.g., Directory, File, Symlink\n * @property {Object.<string, DirectoryStructureA>} [content] Content if directory.\n *\n *\n * @typedef {Object} DirectoryStructureA\n * @property {string} type File type, e.g., Directory, File, Symlink\n * @property {'etc'} [content] Content if directory.\n */\n"],"file":"index.js"}